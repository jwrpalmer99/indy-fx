{
  "version": 1,
  "moduleId": "indy-fx",
  "exportedAt": 1772181602238,
  "shaders": [
    {
      "id": "river-heightmap-flow",
      "name": "River Heightmap Flow",
      "label": "River Heightmap Flow",
      "source": "// River Over Depth Map (top-down)\n// Usage in Indy FX:\n// 1) Import/create a shader and paste this source.\n// 2) Set iChannel0 to your riverbed texture (token/tile image or scene capture).\n// 3) Tune uniforms in Edit Variables (all @editable fields below).\n\nuniform float uFlowAngleDeg;      // @editable 24.0 @tip \"Flow direction in degrees.\"\nuniform float uFlowSpeed;         // @editable 0.28 @tip \"Overall river flow speed.\"\nuniform float uTurbulence;        // @editable 0.7 @tip \"Amount of flow distortion and chaos.\"\nuniform float uPatternScale;      // @editable 1.0 @tip \"Global scale for waves, foam, and silt patterns.\"\nuniform float uWaterLevel;        // @editable 0.5 @tip \"Waterline threshold against depth map.\"\nuniform float uTransparency;      // @editable 0.82 @tip \"Visibility of refracted riverbed through water.\"\nuniform float uRefraction;        // @editable 0.05 @tip \"Base refraction distortion strength.\"\nuniform float uDiffraction;       // @editable 0.0025 @tip \"Chromatic fringe amount around refraction.\"\nuniform float uRefractionFlow;    // @editable 0.55 @tip \"Extra flow-driven refraction strength.\"\nuniform float uIor;               // @editable 1.333 @tip \"Index of refraction used for physical bend.\"\nuniform float uNormalIntensity;   // @editable 1.0 @tip \"Strength of surface normal perturbation.\"\nuniform float uSpecularity;       // @editable 0.8 @tip \"Specular highlight intensity.\"\nuniform float uShininess;         // @editable 48.0 @tip \"Specular highlight sharpness.\"\nuniform float uFoamIntensity;     // @editable 2.0 @tip \"Overall shoreline foam intensity.\"\nuniform float uFoamThreshold;     // @editable 0.02 @tip \"Width of shoreline foam band near waterline.\"\nuniform float uFoamSpeed;         // @editable 0.25 @tip \"How fast foam patterns evolve over time.\"\nuniform float uVortexStrength;    // @editable 0.5 @tip \"Extra turbulent churn contribution to foam.\"\nuniform vec3 uDeepColor;          // @editable 0.01,0.24,0.43 @tip \"Tint color used in deepest water.\"\nuniform vec3 uMediumColor;        // @editable 0.07,0.45,0.57 @tip \"Tint color used in mid-depth water.\"\nuniform vec3 uShallowColor;       // @editable 0.30,0.74,0.67 @tip \"Tint color used in shallow water.\"\nuniform vec3 uDepthWeights;       // @editable -1.0,0.0,1.0 @tip \"RGB channel weights used to derive depth.\"\nuniform float uDepthGamma;        // @editable 1.0 @tip \"Gamma curve applied to depth mapping.\"\nuniform float uFixLand;           // @editable 1.0 @tip \"Enable heuristic correction to suppress land flooding.\"\nuniform float uDebugHeightVsWater;  // @editable 0.0 @tip \"Show depth/waterline debug visualization.\"\nuniform float uSiltIntensity;     // @editable 1.0 @tip \"Overall strength of suspended silt plumes.\"\nuniform float uSiltScale;         // @editable 12.0 @tip \"Scale of silt plume patterns.\"\nuniform float uSiltSpeed;         // @editable 0.25 @tip \"Advection speed of silt through flow.\"\nuniform float uSiltContrast;      // @editable 0.55 @tip \"Contrast of silt cloud breakup.\"\nuniform float uSiltShallowBias;   // @editable 0.65 @tip \"Bias silt placement toward shallow water.\"\nuniform float uSiltDepthBias;     // @editable 0.25 @tip \"Target depth where silt is emphasized.\"\nuniform vec3 uSiltColorA;         // @editable 0.53,0.59,0.42 @tip \"Primary silt tint color.\"\nuniform vec3 uSiltColorB;         // @editable 0.34,0.43,0.30 @tip \"Secondary silt tint color.\"\n\nfloat luma(vec3 c) {\n  return dot(c, vec3(0.2126, 0.7152, 0.0722));\n}\n\nfloat depthMapFromRgb(vec3 c) {\n  vec3 w = uDepthWeights;\n  float wsumAbs = abs(w.x) + abs(w.y) + abs(w.z);\n  // Signed channel weights are supported; positive-only weights behave as before.\n  float d = wsumAbs > 0.00001\n    ? dot(c - vec3(0.5), w) / wsumAbs + 0.5\n    : luma(c);\n  float g = max(0.01, uDepthGamma);\n  float depthLinear = pow(clamp(d, 0.0, 1.0), g);\n  if (uFixLand > 0.5) {\n    // Keep land correction gentle so depth weights remain meaningful.\n    float warmVsBlue = max(c.r - c.b, 0.0);\n    float greenVsBlue = max(c.g - c.b, 0.0);\n    depthLinear -= warmVsBlue * 0.18 + greenVsBlue * 0.10;\n  }\n  depthLinear = clamp(depthLinear, 0.0, 1.0);\n  // Direct mapping: brighter weighted values map to deeper terrain.\n  return depthLinear;\n}\n\nmat2 rot2(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, -s, s, c);\n}\n\nvec2 patternScaleVec() {\n  float aspect = iResolution.x / max(iResolution.y, 1.0);\n  float s = max(0.001, uPatternScale);\n  return vec2(aspect * s, s);\n}\n\nvec2 toPatternUv(vec2 uv) {\n  // Keep procedural patterns square on non-square targets.\n  return (uv - 0.5) * patternScaleVec() + 0.5;\n}\n\nvec2 toPatternDir(vec2 dir) {\n  // Re-normalize directional vectors in pattern space so angle reads consistently.\n  return normalize(dir * patternScaleVec() + vec2(1e-5, 1e-5));\n}\n\nfloat hash12(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.1031);\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise2(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float a = hash12(i + vec2(0.0, 0.0));\n  float b = hash12(i + vec2(1.0, 0.0));\n  float c = hash12(i + vec2(0.0, 1.0));\n  float d = hash12(i + vec2(1.0, 1.0));\n  return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat fbm(vec2 p) {\n  float v = 0.0;\n  float a = 0.5;\n  mat2 m = mat2(0.80, -0.60, 0.60, 0.80);\n  for (int i = 0; i < 3; i += 1) {\n    v += a * noise2(p);\n    p = m * p * 2.01;\n    a *= 0.52;\n  }\n  return v;\n}\n\nfloat sampleDepth(vec2 uv) {\n  return depthMapFromRgb(texture(iChannel0, uv).rgb);\n}\n\nvec2 flowWarp(vec2 p, vec2 flowDir, float t, float turb) {\n  float tt = t * (0.35 + turb * 0.55);\n  vec2 q = vec2(\n    fbm(p * 0.85 + vec2(0.0, tt * 0.9)),\n    fbm(p * 0.82 + vec2(13.7, -tt * 0.7))\n  ) - 0.5;\n  vec2 r = vec2(\n    fbm(p * 1.37 + q * 2.4 + vec2(-tt * 1.3, 4.2)),\n    fbm(p * 1.41 + q * 2.1 + vec2(tt * 1.1, -8.3))\n  ) - 0.5;\n  vec2 swirl = vec2(r.y - q.x, q.y - r.x);\n  float spin = sin(dot(p, flowDir.yx * vec2(1.7, -2.3)) + tt * 2.6);\n  return (swirl * 2.0 + q + r) * (0.25 + turb * 0.9) +\n    flowDir.yx * spin * 0.15 * (0.2 + turb);\n}\n\nfloat surfaceField(vec2 uv, vec2 flowDir, float t, float turb) {\n  vec2 p = uv * 7.5;\n  float advTime = t * (1.0 + turb * 0.9);\n  vec2 baseAdv = p - flowDir * advTime;\n  vec2 warpA = flowWarp(baseAdv + vec2(2.1, -1.3), flowDir, t, turb);\n  vec2 warpB = flowWarp(baseAdv * 1.23 + vec2(-6.2, 4.4), flowDir, t + 3.7, turb);\n  vec2 q1 = baseAdv + warpA;\n  vec2 q2 =\n    baseAdv * 1.75 - warpB * 1.35 +\n    flowDir.yx * sin(t * 1.8 + dot(baseAdv, vec2(1.3, -1.1)));\n\n  float crests =\n    sin(dot(q1, flowDir * vec2(5.8, 4.1)) +\n    fbm(q2 + vec2(t * 0.8, -t * 0.6)) * 3.14159);\n  float chop = sin(dot(q2, flowDir.yx * vec2(3.2, -5.4)) + t * 2.1);\n  float micro = fbm(q1 * 2.2 + warpB * 2.0 + vec2(t * 1.5, -t * 1.2)) * 2.0 - 1.0;\n  float macro = fbm(q2 * 0.95 - warpA * 1.7 + vec2(-t * 0.5, t * 0.4)) * 2.0 - 1.0;\n  float vort = sin((warpA.x - warpB.y) * 8.0 + t * (1.2 + turb * 1.7));\n\n  return\n    crests * 0.35 +\n    chop * 0.22 +\n    micro * 0.28 +\n    macro * 0.18 +\n    vort * 0.16;\n}\n\nvec3 computeSurfaceNormal(vec2 uv, vec2 flowDir, float t, float normalIntensity, float turb) {\n  vec2 e = vec2(1.0 / iResolution.x, 1.0 / iResolution.y) * patternScaleVec();\n  float hL = surfaceField(uv - vec2(e.x, 0.0), flowDir, t, turb);\n  float hR = surfaceField(uv + vec2(e.x, 0.0), flowDir, t, turb);\n  float hD = surfaceField(uv - vec2(0.0, e.y), flowDir, t, turb);\n  float hU = surfaceField(uv + vec2(0.0, e.y), flowDir, t, turb);\n  vec2 g = vec2(hR - hL, hU - hD) * normalIntensity;\n  return normalize(vec3(-g.x, -g.y, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec4 bed = texture(iChannel0, uv);\n  float bedDepthMap = depthMapFromRgb(bed.rgb);\n\n  float t = uTime * max(0.0, uFlowSpeed);\n  vec2 flowDir = normalize(rot2(radians(uFlowAngleDeg)) * vec2(1.0, 0.0));\n  vec2 uvP = toPatternUv(uv);\n  vec2 flowDirP = toPatternDir(flowDir);\n  vec3 N = computeSurfaceNormal(uvP, flowDirP, t, max(0.01, uNormalIntensity), max(0.0, uTurbulence));\n\n  // Depth-map-derived water depth.\n  float rawDepth = uWaterLevel + bedDepthMap - 1.0;\n  float depth = clamp(rawDepth, 0.0, 1.0);\n  float waterMask = smoothstep(0.002, 0.03, depth);\n  if (uDebugHeightVsWater > 0.5) {\n    float level01 = clamp(uWaterLevel, 0.0, 1.0);\n    float edge = 1.0 - smoothstep(0.0, 0.02, abs(rawDepth));\n    vec3 landWater = mix(\n      vec3(0.55, 0.15, 0.10),\n      vec3(0.08, 0.38, 0.90),\n      step(0.0, rawDepth)\n    );\n    // Debug depth ramp: deeper = darker.\n    vec3 debugDepth = vec3(1.0 - bedDepthMap);\n    vec3 debugColor = mix(debugDepth, landWater, 0.65);\n    debugColor = mix(debugColor, vec3(1.0, 0.92, 0.18), edge);\n\n    // Top bar marker for the current water level (normalized 0-1).\n    float barBand = step(uv.y, 0.03);\n    float marker = 1.0 - smoothstep(0.0, 0.0035, abs(uv.x - level01));\n    debugColor = mix(debugColor, vec3(0.02), barBand * 0.65);\n    debugColor = mix(debugColor, vec3(0.0, 1.0, 1.0), barBand * marker);\n\n    fragColor = vec4(debugColor, 1.0);\n    return;\n  }\n\n  // Terrain slope for shoreline foam.\n  vec2 texel = vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n  float hL = sampleDepth(uv - vec2(texel.x, 0.0));\n  float hR = sampleDepth(uv + vec2(texel.x, 0.0));\n  float hD = sampleDepth(uv - vec2(0.0, texel.y));\n  float hU = sampleDepth(uv + vec2(0.0, texel.y));\n  vec2 terrainGrad = vec2(hR - hL, hU - hD);\n  float slope = length(terrainGrad);\n\n  // Refracted riverbed with configurable diffraction.\n  // Blend physical (IOR-based) and flow-driven distortion for readable top-down motion.\n  float eta = 1.0 / max(1.01, uIor);\n  vec3 viewDir = vec3(0.0, 0.0, 1.0);\n  vec3 refrV = refract(-viewDir, N, eta);\n  vec2 physOffset = (refrV.xy / max(0.20, refrV.z + 0.20)) * uRefraction;\n  float flowDistA = surfaceField(uvP * 1.35 + flowDirP * 0.23, flowDirP, t * 1.10, max(0.0, uTurbulence));\n  float flowDistB = surfaceField(uvP * 1.28 + flowDirP.yx * vec2(-0.31, 0.17), flowDirP, t * 0.94, max(0.0, uTurbulence));\n  float flowRefractStrength =\n    (0.015 + 0.030 * clamp(uRefraction, 0.0, 1.5)) *\n    max(0.0, uRefractionFlow);\n  vec2 flowOffset = vec2(flowDistA, flowDistB) * flowRefractStrength;\n  vec2 refractOffset = (physOffset + flowOffset) *\n    mix(0.35, 1.20, smoothstep(0.0, 1.0, depth));\n  vec2 chroma = N.xy * uDiffraction;\n  vec2 uvR = clamp(uv + refractOffset + chroma, 0.0, 1.0);\n  vec2 uvG = clamp(uv + refractOffset, 0.0, 1.0);\n  vec2 uvB = clamp(uv + refractOffset - chroma, 0.0, 1.0);\n  vec3 refractedBed = vec3(\n    texture(iChannel0, uvR).r,\n    texture(iChannel0, uvG).g,\n    texture(iChannel0, uvB).b\n  );\n\n  // Depth color ramp: shallow -> medium -> deep.\n  float dShallowToMid = smoothstep(0.08, 0.45, depth);\n  float dMidToDeep = smoothstep(0.40, 0.95, depth);\n  vec3 waterColor = mix(uShallowColor, uMediumColor, dShallowToMid);\n  waterColor = mix(waterColor, uDeepColor, dMidToDeep);\n\n  // Eddies and vortices in the flow field.\n  vec2 flowUV = uvP * 9.0 - flowDirP * t * 0.75;\n  float eddyNoise = fbm(flowUV + vec2(4.7, -2.1));\n  float eddyBand = sin((eddyNoise * 2.0 - 1.0) * 9.5 + t * 2.2);\n  float eddy = 0.5 + 0.5 * eddyBand;\n\n  // Foam locked to terrain/water onlap: bank-side band shaped by slope/flow.\n  float shoreWidth = max(0.002, uFoamThreshold);\n  // Bank-side foam band only: primarily rawDepth in [-uFoamThreshold, 0].\n  float shoreline = smoothstep(-shoreWidth, 0.0, rawDepth) *\n    (1.0 - step(0.0, rawDepth));\n\n  vec2 bankToShallow = normalize(-terrainGrad + vec2(1e-5, 1e-5));\n  vec2 bankToShallowP = toPatternDir(bankToShallow);\n  float flowImpact = max(0.0, dot(flowDirP, bankToShallowP));\n  float speedFactor = max(0.0, uFlowSpeed);\n  float speedNorm = clamp(speedFactor / 2.0, 0.0, 1.0);\n  float foamSpeed = max(0.0, uFoamSpeed);\n  float foamRate = (0.20 + speedFactor * 0.85) * (0.25 + foamSpeed);\n  vec2 flowNormal = vec2(-flowDirP.y, flowDirP.x);\n\n  // Keep slope response stable as threshold changes to avoid crystalline artifacts.\n  float slopeFoam = smoothstep(0.004, 0.055, slope);\n  float shoreVar = 0.65 + 0.35 * fbm(\n    uvP * 18.0 + bankToShallowP * 0.6 - flowDirP * t * 0.35\n  );\n  float interfaceBase = shoreline * shoreVar * (0.42 + 0.58 * slopeFoam);\n\n  // Build shoreline mist in flow-space with softer, cloud-like breakup.\n  float along = dot(uvP, flowDirP);\n  float across = dot(uvP, flowNormal);\n  vec2 flowCoord = vec2(along, across);\n  vec2 driftDir = normalize(\n    flowDirP * (0.75 + 0.45 * flowImpact) +\n    flowNormal * (0.16 + 0.28 * (1.0 - flowImpact)) +\n    vec2(1e-5, 1e-5)\n  );\n  vec2 foamDrift = driftDir * (uTime * foamRate);\n\n  vec2 mistUvA = flowCoord * vec2(11.0, 7.5) -\n    foamDrift * vec2(2.8, 2.2) + bankToShallowP * 0.45;\n  vec2 mistUvB = flowCoord.yx * vec2(9.2, 8.7) -\n    foamDrift * vec2(3.4, 2.6) - bankToShallowP.yx * 0.35 + vec2(3.7, -2.5);\n  vec2 mistUvC = (mistUvA + mistUvB) * 0.62 + vec2(-4.1, 2.9);\n\n  float mistA = fbm(mistUvA);\n  float mistB = fbm(mistUvB);\n  float mistC = fbm(mistUvC);\n  float mistBody = smoothstep(0.30, 0.82, mistA * 0.48 + mistB * 0.34 + mistC * 0.18);\n  float mistWisp = 1.0 - smoothstep(0.12, 0.56, abs(mistA - mistB));\n  float foamDetail = clamp(mistBody * (0.62 + 0.38 * mistWisp), 0.0, 1.0);\n  float speedFoamBoost = mix(0.72, 1.30, speedNorm);\n  float foam = interfaceBase *\n    speedFoamBoost *\n    (0.68 + 0.32 * flowImpact) *\n    foamDetail;\n  float churn = shoreline *\n    mix(0.20, 0.70, speedNorm) *\n    (0.20 + 0.60 * flowImpact) *\n    uVortexStrength *\n    smoothstep(0.45, 0.90, mistC);\n  float foamMask = clamp((foam + churn * 0.20) * uFoamIntensity, 0.0, 1.0);\n  foamMask = smoothstep(0.0, 0.85, foamMask);\n\n  // Water body composition:\n  // The riverbed is the original scene capture (iChannel0), sampled with refraction.\n  // Depth map is only used to drive tint/opacity, not as the displayed bed color.\n  float transparency = clamp(uTransparency, 0.0, 1.0);\n  float depthTransmission = exp(-depth * 1.9);\n  float depthOcclusion = mix(1.0, depthTransmission, 0.80);\n  // Ensure uTransparency = 1.0 keeps the refracted capture fully visible.\n  float bedVisibility = clamp(\n    transparency * mix(1.0, depthOcclusion, 1.0 - transparency),\n    0.0,\n    1.0\n  );\n  float waterTintStrength = 1.0 - bedVisibility;\n\n  // uTransparency = 0.0 -> fully opaque water (no bed visibility).\n  // uTransparency = 1.0 -> refracted bed strongly visible, especially in shallows.\n  vec3 waterBody = mix(refractedBed, waterColor, waterTintStrength);\n  waterBody += vec3((eddy - 0.5) * 0.03 * bedVisibility);\n\n  // Suspended silt as soft underwater plumes (cloud/smoke-like rather than streaky).\n  float siltScale = max(0.5, uSiltScale);\n  float siltSpeed = max(0.0, uSiltSpeed);\n  float turb = max(0.0, uTurbulence);\n  float siltTravel = t * (0.20 + 0.80 * siltSpeed);\n  vec2 plumeDir = normalize(flowDirP + vec2(1e-5, 1e-5));\n  vec2 plumeBase = uvP * (0.20 * siltScale);\n  vec2 plumeWarp = flowWarp(\n    plumeBase * 0.55 + vec2(2.7, -1.9),\n    flowDirP,\n    t * 0.55 + 0.9,\n    turb\n  ) * (0.45 + 0.35 * turb);\n  vec2 plumeUvA = plumeBase - plumeDir * siltTravel + plumeWarp;\n  vec2 plumeUvB = plumeBase * 1.45 - plumeDir * (siltTravel * 1.2) - plumeWarp * 0.75 + vec2(4.2, -3.6);\n  float plumeA = fbm(plumeUvA);\n  float plumeB = fbm(plumeUvB);\n  float plumeC = fbm((plumeUvA + plumeUvB) * 0.65 + vec2(-2.4, 3.1));\n  float billow = plumeA * 0.52 + plumeB * 0.33 + plumeC * 0.15;\n  float cloudBody = smoothstep(0.30, 0.86, billow);\n  float cloudWisp = 1.0 - smoothstep(0.16, 0.62, abs(plumeA - plumeB));\n  float cloudField = clamp(cloudBody * (0.55 + 0.45 * cloudWisp), 0.0, 1.0);\n  float cloudContrast = clamp(uSiltContrast, 0.0, 1.0);\n  cloudField = smoothstep(\n    max(0.05, cloudContrast * 0.25),\n    min(0.98, 0.55 + cloudContrast * 0.35),\n    cloudField\n  );\n  float shallowMask = 1.0 - smoothstep(0.12, 0.90, depth);\n  // Depth target control for plume placement: 0.0 = shallow, 1.0 = deep.\n  float depthTarget = clamp(uSiltDepthBias, 0.0, 1.0);\n  float targetMask = 1.0 - smoothstep(0.0, 0.55, abs(depth - depthTarget));\n  float siltDepthMask = mix(targetMask, shallowMask, clamp(uSiltShallowBias, 0.0, 1.0));\n  float siltAmount = clamp(uSiltIntensity, 0.0, 2.0) * siltDepthMask * cloudField;\n  // Soft, airy opacity response.\n  float plumeAlpha = 1.0 - exp(-siltAmount * 1.2);\n  vec3 siltTone = mix(uSiltColorA, uSiltColorB, plumeB);\n  vec3 plumeColor = mix(waterBody, siltTone, 0.50);\n  waterBody = mix(waterBody, plumeColor, clamp(plumeAlpha, 0.0, 1.0) * 0.85);\n  waterBody += vec3(0.02) * plumeAlpha * (0.35 + 0.65 * cloudWisp);\n\n  // Simple top-down lighting/specular.\n  vec3 L = normalize(vec3(-0.32, -0.26, 0.91));\n  vec3 V = vec3(0.0, 0.0, 1.0);\n  float ndl = clamp(dot(N, L), 0.0, 1.0);\n  float spec = pow(max(dot(reflect(-L, N), V), 0.0), max(4.0, uShininess));\n  float fresnel = pow(1.0 - clamp(dot(N, V), 0.0, 1.0), 3.0);\n  vec3 specCol = vec3(spec * (0.35 + fresnel) * uSpecularity);\n  waterBody *= (0.96 + 0.04 * ndl);\n\n  vec3 foamColor = vec3(0.95, 0.98, 1.0);\n  float waterFoamMask = foamMask * waterMask * 0.20;\n  float bankFoamMask = foamMask * (1.0 - waterMask);\n  vec3 wetResult = waterBody + specCol;\n  wetResult = mix(wetResult, foamColor, waterFoamMask);\n\n  // Exposed terrain where water is too shallow.\n  vec3 finalColor = mix(bed.rgb, wetResult, waterMask);\n  // Draw primary foam on the bank side of the interface.\n  finalColor = mix(finalColor, mix(bed.rgb, foamColor, 0.88), bankFoamMask);\n  // Scene-capture alpha may be zero on some paths; keep water visible on regions.\n  float finalAlpha = 1.0;\n  fragColor = vec4(finalColor, finalAlpha);\n}\n",
      "referencedChannels": [
        0
      ],
      "channels": {
        "iChannel0": {
          "mode": "sceneCapture",
          "path": "",
          "source": "",
          "channels": {},
          "size": 512,
          "volumeTilesX": 0,
          "volumeTilesY": 0,
          "volumeDepth": 0,
          "volumeSizeX": 0,
          "volumeSizeY": 0,
          "volumeSizeZ": 0,
          "samplerFilter": "",
          "samplerWrap": "",
          "samplerVflip": null,
          "samplerInternal": ""
        },
        "iChannel1": {
          "mode": "none",
          "path": "",
          "source": "",
          "channels": {},
          "size": 512,
          "volumeTilesX": 0,
          "volumeTilesY": 0,
          "volumeDepth": 0,
          "volumeSizeX": 0,
          "volumeSizeY": 0,
          "volumeSizeZ": 0,
          "samplerFilter": "",
          "samplerWrap": "",
          "samplerVflip": null,
          "samplerInternal": ""
        },
        "iChannel2": {
          "mode": "none",
          "path": "",
          "source": "",
          "channels": {},
          "size": 512,
          "volumeTilesX": 0,
          "volumeTilesY": 0,
          "volumeDepth": 0,
          "volumeSizeX": 0,
          "volumeSizeY": 0,
          "volumeSizeZ": 0,
          "samplerFilter": "",
          "samplerWrap": "",
          "samplerVflip": null,
          "samplerInternal": ""
        },
        "iChannel3": {
          "mode": "none",
          "path": "",
          "source": "",
          "channels": {},
          "size": 512,
          "volumeTilesX": 0,
          "volumeTilesY": 0,
          "volumeDepth": 0,
          "volumeSizeX": 0,
          "volumeSizeY": 0,
          "volumeSizeZ": 0,
          "samplerFilter": "",
          "samplerWrap": "",
          "samplerVflip": null,
          "samplerInternal": ""
        }
      },
      "defaults": {
        "layer": "interfacePrimary",
        "useGradientMask": false,
        "gradientMaskFadeStart": 0.8,
        "alpha": 1,
        "intensity": 1,
        "speed": 1,
        "bloom": false,
        "bloomStrength": 1,
        "bloomBlur": 7,
        "bloomQuality": 2,
        "scale": 1,
        "scaleX": 1,
        "scaleY": 1,
        "scaleToToken": false,
        "tokenScaleMultiplier": 1,
        "scaleWithTokenTexture": false,
        "rotateWithToken": false,
        "flipHorizontal": false,
        "flipVertical": false,
        "shaderRotationDeg": 0,
        "shapeDistanceUnits": 20,
        "falloffPower": 1.6,
        "density": 1,
        "flowMode": 0,
        "flowSpeed": 0.8,
        "flowTurbulence": 0.35,
        "colorA": "124A7A",
        "colorB": "4EA88E",
        "captureScale": 1,
        "captureRotationDeg": 0,
        "captureFlipHorizontal": false,
        "captureFlipVertical": false,
        "displayTimeMs": 0,
        "easeInMs": 250,
        "easeOutMs": 250,
        "convertToLightSource": false,
        "lightUseIlluminationShader": false,
        "lightUseBackgroundShader": false,
        "lightFalloffMode": "brightDim",
        "lightColorationIntensity": 1,
        "lightIlluminationIntensity": 1,
        "lightBackgroundIntensity": 1,
        "backgroundGlow": 0,
        "preloadShader": false
      },
      "createdAt": 1772181602238,
      "updatedAt": 1772195951953,
      "thumbnail": ""
    }
  ]
}
