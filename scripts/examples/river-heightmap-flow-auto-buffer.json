{
  "version": 1,
  "moduleId": "indy-fx",
  "exportedAt": 1772282736571,
  "shaders": [
    {
      "id": "river-heightmap-flow-auto-buffer",
      "name": "River Heightmap Flow (Auto Buffer)",
      "label": "River Heightmap Flow (Auto Buffer)",
      "source": "// River Over Auto-Analyzed Capture (top-down)\n// Usage in Indy FX:\n// 1) Import/create a shader and paste this source.\n// 2) Set iChannel0 to your riverbed texture (token/tile image or scene capture).\n// 3) iChannel1 should be the internal analysis buffer provided by the example JSON.\n// 4) Tune uniforms in Edit Variables (all @editable fields below).\n\nuniform float uFlowAngleDeg;      // @editable 24.0 @min -180.0 @max 180.0 @tip \"Flow direction in degrees.\" @order 1\nuniform float uFlowSpeed;         // @editable 0.28 @min 0.01 @max 10.0 @tip \"Overall river flow speed.\" @order 2\nuniform float uTurbulence;        // @editable 0.7 @min 0.0 @max 5.0 @tip \"Amount of flow distortion and chaos.\" @order 4\nuniform float uPatternScale;      // @editable 1.0 @min 0.01 @max 10.0 @tip \"Global scale for waves, foam, and silt patterns.\" @order 3\nuniform float uTransparency;      // @editable 0.82 @min 0.0 @max 1.0 @tip \"Visibility of refracted riverbed through water.\" @order 8\nuniform float uRefraction;        // @editable 0.05 @tip \"Base refraction distortion strength.\"\nuniform float uDiffraction;       // @editable 0.0025 @tip \"Chromatic fringe amount around refraction.\"\nuniform float uRefractionFlow;    // @editable 0.55 @tip \"Extra flow-driven refraction strength.\"\nuniform float uIor;               // @editable 1.333 @tip \"Index of refraction used for physical bend.\"\nuniform float uNormalIntensity;   // @editable 1.0 @tip \"Strength of surface normal perturbation.\"\nuniform float uSpecularity;       // @editable 0.8 @tip \"Specular highlight intensity.\"\nuniform float uShininess;         // @editable 48.0 @tip \"Specular highlight sharpness.\"\nuniform float uFoamIntensity;     // @editable 2.0 @tip \"Overall shoreline foam intensity.\"\nuniform float uFoamThreshold;     // @editable 0.02 @tip \"Width of shoreline foam band near waterline.\"\nuniform float uFoamSpeed;         // @editable 0.25 @tip \"How fast foam patterns evolve over time.\"\nuniform float uVortexStrength;    // @editable 0.5 @tip \"Extra turbulent churn contribution to foam.\"\nuniform vec3 uDeepColor;          // @editable 0.01,0.24,0.43 @tip \"Tint color used in deepest water.\"\nuniform vec3 uMediumColor;        // @editable 0.07,0.45,0.57 @tip \"Tint color used in mid-depth water.\"\nuniform vec3 uShallowColor;       // @editable 0.30,0.74,0.67 @tip \"Tint color used in shallow water.\"\nuniform bool uDebugHeightVsWater;  // @editable false @tip \"Show the auto-analyzed river mask and depth visualization.\" @order 9\nuniform bool uDebugSceneUvGrid;    // @editable false @tip \"Show 2x2 UV debug: TL scene UV grid, TR analysis buffer, BL local UV grid, BR local scene capture.\" @order 10\nuniform float uSiltIntensity;     // @editable 1.0 @tip \"Overall strength of suspended silt plumes.\"\nuniform float uSiltScale;         // @editable 12.0 @tip \"Scale of silt plume patterns.\"\nuniform float uSiltSpeed;         // @editable 0.25 @tip \"Advection speed of silt through flow.\"\nuniform float uSiltContrast;      // @editable 0.55 @tip \"Contrast of silt cloud breakup.\"\nuniform float uSiltShallowBias;   // @editable 0.65 @tip \"Bias silt placement toward shallow water.\"\nuniform float uSiltDepthBias;     // @editable 0.25 @tip \"Target depth where silt is emphasized.\"\nuniform vec3 uSiltColorA;         // @editable 0.53,0.59,0.42 @tip \"Primary silt tint color.\"\nuniform vec3 uSiltColorB;         // @editable 0.34,0.43,0.30 @tip \"Secondary silt tint color.\"\n\nvec4 sampleAnalysis(vec2 uv) {\n  return texture(iChannel1, uv);\n}\n\nfloat analysisGamma() {\n  return max(0.20, uAnalysisGamma);\n}\n\nfloat analysisContrast() {\n  return max(0.0, uAnalysisContrast);\n}\n\nfloat applyAnalysisCurve(float x) {\n  float shaped = pow(clamp(x, 0.0, 1.0), analysisGamma());\n  return clamp((shaped - 0.5) * analysisContrast() + 0.5, 0.0, 1.0);\n}\n\nfloat waterFieldFromAnalysis(vec4 analysis, float waterBias) {\n  float field = clamp(analysis.r + waterBias, 0.0, 1.0);\n  return applyAnalysisCurve(field);\n}\n\nfloat rawDepthFromAnalysis(vec4 analysis, float waterBias) {\n  float waterField = waterFieldFromAnalysis(analysis, waterBias);\n  float interior = applyAnalysisCurve(analysis.g);\n  return (waterField - 0.5) * 0.22 + interior * waterField;\n}\n\nfloat sampleDepth(vec2 uv, float waterBias) {\n  return clamp(rawDepthFromAnalysis(sampleAnalysis(uv), waterBias), 0.0, 1.0);\n}\n\nfloat gridLine(vec2 uv, float cells, float thickness) {\n  vec2 f = fract(uv * cells);\n  vec2 d = min(f, 1.0 - f) / max(cells, 1.0);\n  return 1.0 - smoothstep(0.0, thickness, min(d.x, d.y));\n}\n\nvec3 debugGridView(vec2 uv) {\n  float major = gridLine(uv, 10.0, 0.0035);\n  float minor = gridLine(uv, 40.0, 0.0012);\n  float axisX = 1.0 - smoothstep(0.0, 0.005, abs(uv.x - 0.5));\n  float axisY = 1.0 - smoothstep(0.0, 0.005, abs(uv.y - 0.5));\n  vec3 gridView = vec3(uv.x, uv.y, 1.0 - 0.5 * (uv.x + uv.y));\n  gridView = mix(gridView, vec3(0.05), minor * 0.35);\n  gridView = mix(gridView, vec3(1.0), major * 0.85);\n  gridView = mix(gridView, vec3(1.0, 0.20, 0.20), axisX * 0.75);\n  gridView = mix(gridView, vec3(0.20, 1.0, 0.20), axisY * 0.75);\n  return gridView;\n}\n\nvec3 debugSampleView(vec2 uv, vec3 sampled) {\n  float major = gridLine(uv, 10.0, 0.0030);\n  float minor = gridLine(uv, 40.0, 0.0010);\n  vec3 sampleView = sampled;\n  sampleView = mix(sampleView, vec3(1.0), major * 0.35);\n  sampleView = mix(sampleView, vec3(0.08), minor * 0.18);\n  return sampleView;\n}\n\nvec3 sceneUvGridDebug(vec2 rawUv, vec3 analysisSample, vec3 captureSample) {\n  vec2 quadUv = fract(rawUv * 2.0);\n  vec2 sceneUv = cpfx_sceneUvFromRaw(quadUv);\n  bool left = rawUv.x < 0.5;\n  bool top = rawUv.y >= 0.5;\n\n  vec3 debugColor;\n  if (left && top) {\n    debugColor = debugGridView(sceneUv);\n  } else if (!left && top) {\n    debugColor = debugSampleView(quadUv, analysisSample);\n  } else if (left && !top) {\n    debugColor = debugGridView(quadUv);\n  } else {\n    debugColor = debugSampleView(quadUv, captureSample);\n  }\n\n  float dividerX = 1.0 - smoothstep(0.0, 0.003, abs(rawUv.x - 0.5));\n  float dividerY = 1.0 - smoothstep(0.0, 0.003, abs(rawUv.y - 0.5));\n  debugColor = mix(debugColor, vec3(1.0, 0.92, 0.18), max(dividerX, dividerY));\n\n  float edgeDist = min(\n    min(quadUv.x, 1.0 - quadUv.x),\n    min(quadUv.y, 1.0 - quadUv.y)\n  );\n  float innerFrame = 1.0 - smoothstep(0.0, 0.004, edgeDist);\n  debugColor = mix(debugColor, vec3(0.04), innerFrame * 0.35);\n  return debugColor;\n}\n\nmat2 rot2(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, -s, s, c);\n}\n\nfloat patternScalePx() {\n  // Use local pixel space so pattern density stays consistent across differently sized regions.\n  return max(0.001, uPatternScale) / 512.0;\n}\n\nvec2 toPatternUv(vec2 fragCoordPx) {\n  return fragCoordPx * patternScalePx();\n}\n\nvec2 toPatternDir(vec2 dir) {\n  return normalize(dir + vec2(1e-5, 1e-5));\n}\n\nvec2 patternTexelStep() {\n  float s = patternScalePx();\n  return vec2(s, s);\n}\n\nfloat hash12(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.1031);\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise2(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float a = hash12(i + vec2(0.0, 0.0));\n  float b = hash12(i + vec2(1.0, 0.0));\n  float c = hash12(i + vec2(0.0, 1.0));\n  float d = hash12(i + vec2(1.0, 1.0));\n  return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat fbm(vec2 p) {\n  float v = 0.0;\n  float a = 0.5;\n  mat2 m = mat2(0.80, -0.60, 0.60, 0.80);\n  for (int i = 0; i < 3; i += 1) {\n    v += a * noise2(p);\n    p = m * p * 2.01;\n    a *= 0.52;\n  }\n  return v;\n}\n\nvec2 flowWarp(vec2 p, vec2 flowDir, float t, float turb) {\n  float tt = t * (0.35 + turb * 0.55);\n  vec2 q = vec2(\n    fbm(p * 0.85 + vec2(0.0, tt * 0.9)),\n    fbm(p * 0.82 + vec2(13.7, -tt * 0.7))\n  ) - 0.5;\n  vec2 r = vec2(\n    fbm(p * 1.37 + q * 2.4 + vec2(-tt * 1.3, 4.2)),\n    fbm(p * 1.41 + q * 2.1 + vec2(tt * 1.1, -8.3))\n  ) - 0.5;\n  vec2 swirl = vec2(r.y - q.x, q.y - r.x);\n  float spin = sin(dot(p, flowDir.yx * vec2(1.7, -2.3)) + tt * 2.6);\n  return (swirl * 2.0 + q + r) * (0.25 + turb * 0.9) +\n    flowDir.yx * spin * 0.15 * (0.2 + turb);\n}\n\nfloat surfaceField(vec2 uv, vec2 flowDir, float t, float turb) {\n  vec2 p = uv * 7.5;\n  float advTime = t * (1.0 + turb * 0.9);\n  vec2 baseAdv = p - flowDir * advTime;\n  vec2 warpA = flowWarp(baseAdv + vec2(2.1, -1.3), flowDir, t, turb);\n  vec2 warpB = flowWarp(baseAdv * 1.23 + vec2(-6.2, 4.4), flowDir, t + 3.7, turb);\n  vec2 q1 = baseAdv + warpA;\n  vec2 q2 =\n    baseAdv * 1.75 - warpB * 1.35 +\n    flowDir.yx * sin(t * 1.8 + dot(baseAdv, vec2(1.3, -1.1)));\n\n  float crests =\n    sin(dot(q1, flowDir * vec2(5.8, 4.1)) +\n    fbm(q2 + vec2(t * 0.8, -t * 0.6)) * 3.14159);\n  float chop = sin(dot(q2, flowDir.yx * vec2(3.2, -5.4)) + t * 2.1);\n  float micro = fbm(q1 * 2.2 + warpB * 2.0 + vec2(t * 1.5, -t * 1.2)) * 2.0 - 1.0;\n  float macro = fbm(q2 * 0.95 - warpA * 1.7 + vec2(-t * 0.5, t * 0.4)) * 2.0 - 1.0;\n  float vort = sin((warpA.x - warpB.y) * 8.0 + t * (1.2 + turb * 1.7));\n\n  return\n    crests * 0.35 +\n    chop * 0.22 +\n    micro * 0.28 +\n    macro * 0.18 +\n    vort * 0.16;\n}\n\nvec3 computeSurfaceNormal(vec2 uv, vec2 flowDir, float t, float normalIntensity, float turb) {\n  vec2 e = patternTexelStep();\n  float hL = surfaceField(uv - vec2(e.x, 0.0), flowDir, t, turb);\n  float hR = surfaceField(uv + vec2(e.x, 0.0), flowDir, t, turb);\n  float hD = surfaceField(uv - vec2(0.0, e.y), flowDir, t, turb);\n  float hU = surfaceField(uv + vec2(0.0, e.y), flowDir, t, turb);\n  vec2 g = vec2(hR - hL, hU - hD) * normalIntensity;\n  return normalize(vec3(-g.x, -g.y, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 rawUv = cpfx_rawUv();\n  vec2 quadUv = fract(rawUv * 2.0);\n  vec4 bed = texture(iChannel0, uv);\n  vec4 analysis = sampleAnalysis(uv);\n  float analysisShore = unpackShore(analysis.b);\n  float waterBias = (clamp(uWaterLevel, 0.0, 1.0) - 0.5) * 0.20;\n\n  if (uDebugSceneUvGrid) {\n    vec3 analysisQuad = sampleAnalysis(quadUv).rgb;\n    analysisQuad.r = applyAnalysisCurve(analysisQuad.r);\n    analysisQuad.g = applyAnalysisCurve(analysisQuad.g);\n    vec3 captureQuad = texture(iChannel0, quadUv).rgb;\n    fragColor = vec4(sceneUvGridDebug(rawUv, analysisQuad, captureQuad), 1.0);\n    return;\n  }\n\n  float t = uTime * max(0.0, uFlowSpeed);\n  vec2 flowDir = normalize(rot2(radians(uFlowAngleDeg)) * vec2(1.0, 0.0));\n  vec2 uvP = toPatternUv(fragCoord.xy);\n  vec2 flowDirP = toPatternDir(flowDir);\n  vec3 N = computeSurfaceNormal(uvP, flowDirP, t, max(0.01, uNormalIntensity), max(0.0, uTurbulence));\n\n  // Buffer-derived water field and interior depth.\n  float waterField = waterFieldFromAnalysis(analysis, waterBias);\n  float bedDepthMap = applyAnalysisCurve(analysis.g);\n  float rawDepth = rawDepthFromAnalysis(analysis, waterBias);\n  float depth = clamp(rawDepth, 0.0, 1.0);\n  float waterMask = smoothstep(0.002, 0.03, depth);\n  if (uDebugHeightVsWater) {\n    float level01 = clamp(uWaterLevel, 0.0, 1.0);\n    float edge = 1.0 - smoothstep(0.0, 0.02, abs(rawDepth));\n    vec3 landWater = mix(\n      vec3(0.55, 0.15, 0.10),\n      vec3(0.08, 0.38, 0.90),\n      step(0.0, rawDepth)\n    );\n    // Debug depth ramp: deeper = darker, with auto mask confidence mixed in.\n    vec3 debugDepth = vec3(1.0 - bedDepthMap);\n    vec3 debugColor = mix(debugDepth, landWater, 0.55 + 0.25 * waterField);\n    debugColor = mix(debugColor, vec3(1.0), analysisShore * 0.25);\n    debugColor = mix(debugColor, vec3(1.0, 0.92, 0.18), edge);\n\n    // Top bar marker for the current water level (normalized 0-1).\n    float barBand = step(uv.y, 0.03);\n    float marker = 1.0 - smoothstep(0.0, 0.0035, abs(uv.x - level01));\n    debugColor = mix(debugColor, vec3(0.02), barBand * 0.65);\n    debugColor = mix(debugColor, vec3(0.0, 1.0, 1.0), barBand * marker);\n\n    fragColor = vec4(debugColor, 1.0);\n    return;\n  }\n\n  // Terrain slope for shoreline foam.\n  vec2 texel = vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n  float hL = sampleDepth(uv - vec2(texel.x, 0.0), waterBias);\n  float hR = sampleDepth(uv + vec2(texel.x, 0.0), waterBias);\n  float hD = sampleDepth(uv - vec2(0.0, texel.y), waterBias);\n  float hU = sampleDepth(uv + vec2(0.0, texel.y), waterBias);\n  vec2 terrainGrad = vec2(hR - hL, hU - hD);\n  float slope = length(terrainGrad) + analysisShore * 0.03;\n\n  // Refracted riverbed with configurable diffraction.\n  // Blend physical (IOR-based) and flow-driven distortion for readable top-down motion.\n  float eta = 1.0 / max(1.01, uIor);\n  vec3 viewDir = vec3(0.0, 0.0, 1.0);\n  vec3 refrV = refract(-viewDir, N, eta);\n  vec2 physOffset = (refrV.xy / max(0.20, refrV.z + 0.20)) * uRefraction;\n  float flowDistA = surfaceField(uvP * 1.35 + flowDirP * 0.23, flowDirP, t * 1.10, max(0.0, uTurbulence));\n  float flowDistB = surfaceField(uvP * 1.28 + flowDirP.yx * vec2(-0.31, 0.17), flowDirP, t * 0.94, max(0.0, uTurbulence));\n  float flowRefractStrength =\n    (0.015 + 0.030 * clamp(uRefraction, 0.0, 1.5)) *\n    max(0.0, uRefractionFlow);\n  vec2 flowOffset = vec2(flowDistA, flowDistB) * flowRefractStrength;\n  vec2 refractOffset = (physOffset + flowOffset) *\n    mix(0.35, 1.20, smoothstep(0.0, 1.0, depth));\n  vec2 chroma = N.xy * uDiffraction;\n  vec2 uvR = clamp(uv + refractOffset + chroma, 0.0, 1.0);\n  vec2 uvG = clamp(uv + refractOffset, 0.0, 1.0);\n  vec2 uvB = clamp(uv + refractOffset - chroma, 0.0, 1.0);\n  vec3 refractedBed = vec3(\n    texture(iChannel0, uvR).r,\n    texture(iChannel0, uvG).g,\n    texture(iChannel0, uvB).b\n  );\n\n  // Depth color ramp: shallow -> medium -> deep.\n  float dShallowToMid = smoothstep(0.08, 0.45, depth);\n  float dMidToDeep = smoothstep(0.40, 0.95, depth);\n  vec3 waterColor = mix(uShallowColor, uMediumColor, dShallowToMid);\n  waterColor = mix(waterColor, uDeepColor, dMidToDeep);\n\n  // Eddies and vortices in the flow field.\n  vec2 flowUV = uvP * 9.0 - flowDirP * t * 0.75;\n  float eddyNoise = fbm(flowUV + vec2(4.7, -2.1));\n  float eddyBand = sin((eddyNoise * 2.0 - 1.0) * 9.5 + t * 2.2);\n  float eddy = 0.5 + 0.5 * eddyBand;\n\n  // Foam locked to terrain/water onlap: bank-side band shaped by slope/flow.\n  float shoreWidth = max(0.002, uFoamThreshold);\n  // Bank-side foam band only: primarily rawDepth in [-uFoamThreshold, 0].\n  float shoreline = smoothstep(-shoreWidth, 0.0, rawDepth) *\n    (1.0 - step(0.0, rawDepth));\n\n  vec2 bankToShallow = normalize(-terrainGrad + vec2(1e-5, 1e-5));\n  vec2 bankToShallowP = toPatternDir(bankToShallow);\n  float flowImpact = max(0.0, dot(flowDirP, bankToShallowP));\n  float speedFactor = max(0.0, uFlowSpeed);\n  float speedNorm = clamp(speedFactor / 2.0, 0.0, 1.0);\n  float foamSpeed = max(0.0, uFoamSpeed);\n  float foamRate = (0.20 + speedFactor * 0.85) * (0.25 + foamSpeed);\n  vec2 flowNormal = vec2(-flowDirP.y, flowDirP.x);\n\n  // Keep slope response stable as threshold changes to avoid crystalline artifacts.\n  float slopeFoam = smoothstep(0.004, 0.055, slope);\n  float shoreVar = 0.65 + 0.35 * fbm(\n    uvP * 18.0 + bankToShallowP * 0.6 - flowDirP * t * 0.35\n  );\n  float interfaceBase = shoreline * shoreVar * (0.42 + 0.58 * slopeFoam);\n\n  // Build shoreline mist in flow-space with softer, cloud-like breakup.\n  float along = dot(uvP, flowDirP);\n  float across = dot(uvP, flowNormal);\n  vec2 flowCoord = vec2(along, across);\n  vec2 driftDir = normalize(\n    flowDirP * (0.75 + 0.45 * flowImpact) +\n    flowNormal * (0.16 + 0.28 * (1.0 - flowImpact)) +\n    vec2(1e-5, 1e-5)\n  );\n  vec2 foamDrift = driftDir * (uTime * foamRate);\n\n  vec2 mistUvA = flowCoord * vec2(11.0, 7.5) -\n    foamDrift * vec2(2.8, 2.2) + bankToShallowP * 0.45;\n  vec2 mistUvB = flowCoord.yx * vec2(9.2, 8.7) -\n    foamDrift * vec2(3.4, 2.6) - bankToShallowP.yx * 0.35 + vec2(3.7, -2.5);\n  vec2 mistUvC = (mistUvA + mistUvB) * 0.62 + vec2(-4.1, 2.9);\n\n  float mistA = fbm(mistUvA);\n  float mistB = fbm(mistUvB);\n  float mistC = fbm(mistUvC);\n  float mistBody = smoothstep(0.30, 0.82, mistA * 0.48 + mistB * 0.34 + mistC * 0.18);\n  float mistWisp = 1.0 - smoothstep(0.12, 0.56, abs(mistA - mistB));\n  float foamDetail = clamp(mistBody * (0.62 + 0.38 * mistWisp), 0.0, 1.0);\n  float speedFoamBoost = mix(0.72, 1.30, speedNorm);\n  float foam = interfaceBase *\n    speedFoamBoost *\n    (0.68 + 0.32 * flowImpact) *\n    foamDetail;\n  float churn = shoreline *\n    mix(0.20, 0.70, speedNorm) *\n    (0.20 + 0.60 * flowImpact) *\n    uVortexStrength *\n    smoothstep(0.45, 0.90, mistC);\n  float foamMask = clamp((foam + churn * 0.20) * uFoamIntensity, 0.0, 1.0);\n  foamMask = smoothstep(0.0, 0.85, foamMask);\n\n  // Water body composition:\n  // The riverbed is the original scene capture (iChannel0), sampled with refraction.\n  // Depth map is only used to drive tint/opacity, not as the displayed bed color.\n  float transparency = clamp(uTransparency, 0.0, 1.0);\n  float depthTransmission = exp(-depth * 1.9);\n  float depthOcclusion = mix(1.0, depthTransmission, 0.80);\n  // Ensure uTransparency = 1.0 keeps the refracted capture fully visible.\n  float bedVisibility = clamp(\n    transparency * mix(1.0, depthOcclusion, 1.0 - transparency),\n    0.0,\n    1.0\n  );\n  float waterTintStrength = 1.0 - bedVisibility;\n  float hazeStrength =\n    (1.0 - transparency) *\n    waterField *\n    smoothstep(0.04, 0.30, depth);\n\n  // uTransparency = 0.0 -> fully opaque water (no bed visibility).\n  // uTransparency = 1.0 -> refracted bed strongly visible, especially in shallows.\n  vec3 waterBody = mix(refractedBed, waterColor, waterTintStrength);\n  waterBody += vec3((eddy - 0.5) * 0.03 * hazeStrength);\n\n  // Suspended silt as soft underwater plumes (cloud/smoke-like rather than streaky).\n  float siltScale = max(0.5, uSiltScale);\n  float siltSpeed = max(0.0, uSiltSpeed);\n  float turb = max(0.0, uTurbulence);\n  float siltTravel = t * (0.20 + 0.80 * siltSpeed);\n  vec2 plumeDir = normalize(flowDirP + vec2(1e-5, 1e-5));\n  vec2 plumeBase = uvP * (0.20 * siltScale);\n  vec2 plumeWarp = flowWarp(\n    plumeBase * 0.55 + vec2(2.7, -1.9),\n    flowDirP,\n    t * 0.55 + 0.9,\n    turb\n  ) * (0.45 + 0.35 * turb);\n  vec2 plumeUvA = plumeBase - plumeDir * siltTravel + plumeWarp;\n  vec2 plumeUvB = plumeBase * 1.45 - plumeDir * (siltTravel * 1.2) - plumeWarp * 0.75 + vec2(4.2, -3.6);\n  float plumeA = fbm(plumeUvA);\n  float plumeB = fbm(plumeUvB);\n  float plumeC = fbm((plumeUvA + plumeUvB) * 0.65 + vec2(-2.4, 3.1));\n  float billow = plumeA * 0.52 + plumeB * 0.33 + plumeC * 0.15;\n  float cloudBody = smoothstep(0.30, 0.86, billow);\n  float cloudWisp = 1.0 - smoothstep(0.16, 0.62, abs(plumeA - plumeB));\n  float cloudField = clamp(cloudBody * (0.55 + 0.45 * cloudWisp), 0.0, 1.0);\n  float cloudContrast = clamp(uSiltContrast, 0.0, 1.0);\n  cloudField = smoothstep(\n    max(0.05, cloudContrast * 0.25),\n    min(0.98, 0.55 + cloudContrast * 0.35),\n    cloudField\n  );\n  float shallowMask = 1.0 - smoothstep(0.12, 0.90, depth);\n  // Depth target control for plume placement: 0.0 = shallow, 1.0 = deep.\n  float depthTarget = clamp(uSiltDepthBias, 0.0, 1.0);\n  float targetMask = 1.0 - smoothstep(0.0, 0.55, abs(depth - depthTarget));\n  float siltDepthMask = mix(targetMask, shallowMask, clamp(uSiltShallowBias, 0.0, 1.0));\n  float siltAmount = clamp(uSiltIntensity, 0.0, 2.0) * siltDepthMask * cloudField;\n  // Soft, airy opacity response.\n  float plumeAlpha = 1.0 - exp(-siltAmount * 1.2);\n  vec3 siltTone = mix(uSiltColorA, uSiltColorB, plumeB);\n  vec3 plumeColor = mix(waterBody, siltTone, 0.50);\n  waterBody = mix(waterBody, plumeColor, clamp(plumeAlpha, 0.0, 1.0) * 0.85);\n  waterBody += vec3(0.02) * plumeAlpha * (0.35 + 0.65 * cloudWisp);\n\n  // Simple top-down lighting/specular.\n  vec3 L = normalize(vec3(-0.32, -0.26, 0.91));\n  vec3 V = vec3(0.0, 0.0, 1.0);\n  float ndl = clamp(dot(N, L), 0.0, 1.0);\n  float spec = pow(max(dot(reflect(-L, N), V), 0.0), max(4.0, uShininess));\n  float fresnel = pow(1.0 - clamp(dot(N, V), 0.0, 1.0), 3.0);\n  vec3 specCol = vec3(spec * (0.35 + fresnel) * uSpecularity);\n  waterBody *= (0.96 + 0.04 * ndl);\n\n  vec3 foamColor = vec3(0.95, 0.98, 1.0);\n  float waterFoamMask = foamMask * waterMask * 0.20;\n  float bankFoamMask = foamMask * (1.0 - waterMask);\n  vec3 wetResult = waterBody + specCol;\n  wetResult = mix(wetResult, foamColor, waterFoamMask);\n\n  // Exposed terrain where water is too shallow.\n  vec3 finalColor = mix(bed.rgb, wetResult, waterMask);\n  // Draw primary foam on the bank side of the interface.\n  finalColor = mix(finalColor, mix(bed.rgb, foamColor, 0.88), bankFoamMask);\n  // Scene-capture alpha may be zero on some paths; keep water visible on regions.\n  float finalAlpha = 1.0;\n  fragColor = vec4(finalColor, finalAlpha);\n}\n\r\n",
      "referencedChannels": [
        0,
        1
      ],
      "channels": {
        "iChannel0": {
          "mode": "sceneCapture",
          "path": "",
          "source": "",
          "channels": {},
          "size": 512,
          "volumeTilesX": 0,
          "volumeTilesY": 0,
          "volumeDepth": 0,
          "volumeSizeX": 0,
          "volumeSizeY": 0,
          "volumeSizeZ": 0,
          "samplerFilter": "",
          "samplerWrap": "",
          "samplerVflip": null,
          "samplerInternal": ""
        },
        "iChannel1": {
          "mode": "buffer",
          "path": "",
          "source": "// River analysis buffer for the auto-analyzed capture variant.\n// R = final visible water mask (base detector only)\n// G = final visible interior depth estimate\n// B = shoreline / edge confidence\n// A = unused\n// Shared analysis controls are declared in the shader's commonSource.\n\nfloat luma(vec3 c) {\n  return dot(c, vec3(0.2126, 0.7152, 0.0722));\n}\n\nfloat saturation(vec3 c) {\n  float maxC = max(max(c.r, c.g), c.b);\n  float minC = min(min(c.r, c.g), c.b);\n  return (maxC - minC) / max(0.08, maxC);\n}\n\nfloat boostedBlue(vec3 c) {\n  float blueLead = max(c.b - max(c.r, c.g), 0.0);\n  return clamp(c.b + blueLead * max(0.0, uAnalysisBlueBoost), 0.0, 1.0);\n}\n\nfloat coolMetric(vec3 c) {\n  return boostedBlue(c) - 0.5 * (c.r + c.g);\n}\n\nfloat quickWaterHint(vec3 c) {\n  float blue = boostedBlue(c);\n  float cool = coolMetric(c);\n  float cyan = min(c.g, blue) - c.r;\n  float coolScore = smoothstep(-0.01, 0.22, max(cool, cyan * 0.85));\n  float bluePresence = smoothstep(0.15, 0.78, blue);\n  float darkAssist = smoothstep(0.15, 0.80, 1.0 - luma(c));\n  float sat = saturation(c);\n  float score = bluePresence * mix(coolScore, max(coolScore, darkAssist), 0.22);\n  score *= 0.82 + 0.18 * smoothstep(0.02, 0.35, sat);\n  return clamp(score, 0.0, 1.0);\n}\n\nfloat boundaryBarrier(\n  vec3 c,\n  vec3 cL,\n  vec3 cR,\n  vec3 cD,\n  vec3 cU\n) {\n  float lit = luma(c);\n  float litDiff = max(\n    max(abs(lit - luma(cL)), abs(lit - luma(cR))),\n    max(abs(lit - luma(cD)), abs(lit - luma(cU)))\n  );\n  float cool = coolMetric(c);\n  float coolDiff = max(\n    max(abs(cool - coolMetric(cL)), abs(cool - coolMetric(cR))),\n    max(abs(cool - coolMetric(cD)), abs(cool - coolMetric(cU)))\n  );\n  float sat = saturation(c);\n  float darkLine = smoothstep(0.22, 0.78, 1.0 - lit);\n  float neutralLine = 1.0 - smoothstep(0.08, 0.40, sat);\n  float localEdge = smoothstep(0.035, 0.16, max(litDiff, coolDiff * 0.85));\n  return clamp(localEdge * darkLine * neutralLine, 0.0, 1.0);\n}\n\nvec2 classifyBaseRiver(\n  vec3 c,\n  vec3 localMean,\n  float neighborhoodHint\n) {\n  float blue = boostedBlue(c);\n  float sat = saturation(c);\n  float lit = luma(c);\n  float meanLit = luma(localMean);\n\n  float cool = coolMetric(c);\n  float meanCool = coolMetric(localMean);\n  float cyan = min(c.g, blue) - c.r;\n\n  float localCool = cool - meanCool * 0.55;\n  float coolScore = smoothstep(-0.02, 0.18, max(localCool, cyan * 0.80));\n  float bluePresence = smoothstep(0.16, 0.82, blue);\n  float localDark = smoothstep(-0.01, 0.28, meanLit - lit + sat * 0.04);\n  float meanBias = smoothstep(0.0, 0.18, meanCool) * 0.12;\n\n  float baseMask = bluePresence * mix(coolScore, max(coolScore, localDark), 0.35);\n  baseMask = mix(baseMask, neighborhoodHint, 0.45);\n  baseMask = clamp(baseMask + meanBias, 0.0, 1.0);\n\n  float deepBlue = smoothstep(0.02, 0.42, blue - 0.24 * c.r - 0.14 * c.g);\n  float interiorDark = smoothstep(0.0, 0.32, meanLit - lit + 0.05);\n  float baseDepth = clamp(baseMask * (deepBlue * 0.55 + interiorDark * 0.45), 0.0, 1.0);\n\n  return vec2(baseMask, baseDepth);\n}\n\nvec3 sampleCaptureLocal(vec2 uv) {\n  return texture(iChannel0, uv).rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 texel = vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n\n  vec3 c = sampleCaptureLocal(uv);\n  vec3 cL = sampleCaptureLocal(uv - vec2(texel.x, 0.0));\n  vec3 cR = sampleCaptureLocal(uv + vec2(texel.x, 0.0));\n  vec3 cD = sampleCaptureLocal(uv - vec2(0.0, texel.y));\n  vec3 cU = sampleCaptureLocal(uv + vec2(0.0, texel.y));\n  vec3 cDL = sampleCaptureLocal(uv - texel);\n  vec3 cDR = sampleCaptureLocal(uv + vec2(texel.x, -texel.y));\n  vec3 cUL = sampleCaptureLocal(uv + vec2(-texel.x, texel.y));\n  vec3 cUR = sampleCaptureLocal(uv + texel);\n\n  vec3 localMean =\n    (c + cL + cR + cD + cU + cDL + cDR + cUL + cUR) / 9.0;\n  float edgeBarrier = boundaryBarrier(c, cL, cR, cD, cU);\n\n  float hC = quickWaterHint(c);\n  float hL = quickWaterHint(cL);\n  float hR = quickWaterHint(cR);\n  float hD = quickWaterHint(cD);\n  float hU = quickWaterHint(cU);\n  float hDL = quickWaterHint(cDL);\n  float hDR = quickWaterHint(cDR);\n  float hUL = quickWaterHint(cUL);\n  float hUR = quickWaterHint(cUR);\n\n  float hint =\n    hC * 0.32 +\n    hL * 0.10 +\n    hR * 0.10 +\n    hD * 0.10 +\n    hU * 0.10 +\n    hDL * 0.07 +\n    hDR * 0.07 +\n    hUL * 0.07 +\n    hUR * 0.07;\n\n  vec2 baseRiver = classifyBaseRiver(c, localMean, hint);\n  float finalMask = baseRiver.x;\n  float depth = clamp(baseRiver.y, 0.0, 1.0);\n\n  float litGrad =\n    abs(luma(cR) - luma(cL)) +\n    abs(luma(cU) - luma(cD));\n  float coolGrad =\n    abs(coolMetric(cR) - coolMetric(cL)) +\n    abs(coolMetric(cU) - coolMetric(cD));\n  float edge = max(\n    edgeBarrier,\n    smoothstep(0.03, 0.22, max(litGrad, coolGrad * 1.15))\n  );\n  float shore = edge * finalMask * (1.0 - smoothstep(0.18, 0.92, depth));\n\n  fragColor = vec4(\n    finalMask,\n    depth,\n    packShoreSettled(clamp(shore, 0.0, 1.0), 0.0),\n    0.0\n  );\n}\n",
          "channels": {
            "iChannel0": {
              "mode": "sceneCapture",
              "path": "",
              "source": "",
              "channels": {},
              "size": 512,
              "volumeTilesX": 0,
              "volumeTilesY": 0,
              "volumeDepth": 0,
              "volumeSizeX": 0,
              "volumeSizeY": 0,
              "volumeSizeZ": 0,
              "samplerFilter": "",
              "samplerWrap": "",
              "samplerVflip": null,
              "samplerInternal": ""
            },
            "iChannel1": {
              "mode": "none",
              "path": "",
              "source": "",
              "channels": {},
              "size": 512,
              "volumeTilesX": 0,
              "volumeTilesY": 0,
              "volumeDepth": 0,
              "volumeSizeX": 0,
              "volumeSizeY": 0,
              "volumeSizeZ": 0,
              "samplerFilter": "",
              "samplerWrap": "",
              "samplerVflip": null,
              "samplerInternal": ""
            },
            "iChannel2": {
              "mode": "none",
              "path": "",
              "source": "",
              "channels": {},
              "size": 512,
              "volumeTilesX": 0,
              "volumeTilesY": 0,
              "volumeDepth": 0,
              "volumeSizeX": 0,
              "volumeSizeY": 0,
              "volumeSizeZ": 0,
              "samplerFilter": "",
              "samplerWrap": "",
              "samplerVflip": null,
              "samplerInternal": ""
            },
            "iChannel3": {
              "mode": "none",
              "path": "",
              "source": "",
              "channels": {},
              "size": 512,
              "volumeTilesX": 0,
              "volumeTilesY": 0,
              "volumeDepth": 0,
              "volumeSizeX": 0,
              "volumeSizeY": 0,
              "volumeSizeZ": 0,
              "samplerFilter": "",
              "samplerWrap": "",
              "samplerVflip": null,
              "samplerInternal": ""
            }
          },
          "size": 512,
          "volumeTilesX": 0,
          "volumeTilesY": 0,
          "volumeDepth": 0,
          "volumeSizeX": 0,
          "volumeSizeY": 0,
          "volumeSizeZ": 0,
          "samplerFilter": "linear",
          "samplerWrap": "clamp",
          "samplerVflip": true,
          "samplerInternal": ""
        },
        "iChannel2": {
          "mode": "none",
          "path": "",
          "source": "",
          "channels": {},
          "size": 512,
          "volumeTilesX": 0,
          "volumeTilesY": 0,
          "volumeDepth": 0,
          "volumeSizeX": 0,
          "volumeSizeY": 0,
          "volumeSizeZ": 0,
          "samplerFilter": "",
          "samplerWrap": "",
          "samplerVflip": null,
          "samplerInternal": ""
        },
        "iChannel3": {
          "mode": "none",
          "path": "",
          "source": "",
          "channels": {},
          "size": 512,
          "volumeTilesX": 0,
          "volumeTilesY": 0,
          "volumeDepth": 0,
          "volumeSizeX": 0,
          "volumeSizeY": 0,
          "volumeSizeZ": 0,
          "samplerFilter": "",
          "samplerWrap": "",
          "samplerVflip": null,
          "samplerInternal": ""
        }
      },
      "defaults": {
        "layer": "interfacePrimary",
        "useGradientMask": false,
        "gradientMaskFadeStart": 0.8,
        "alpha": 1,
        "intensity": 1,
        "speed": 1,
        "bloom": false,
        "bloomStrength": 1,
        "bloomBlur": 7,
        "bloomQuality": 2,
        "scale": 1,
        "scaleX": 1,
        "scaleY": 1,
        "scaleToToken": false,
        "tokenScaleMultiplier": 1,
        "scaleWithTokenTexture": false,
        "rotateWithToken": false,
        "flipHorizontal": false,
        "flipVertical": false,
        "shaderRotationDeg": 0,
        "shapeDistanceUnits": 20,
        "falloffPower": 1.6,
        "density": 1,
        "flowMode": 0,
        "flowSpeed": 0.8,
        "flowTurbulence": 0.35,
        "colorA": "124A7A",
        "colorB": "4EA88E",
        "captureScale": 1,
        "captureRotationDeg": 0,
        "captureFlipHorizontal": false,
        "captureFlipVertical": false,
        "displayTimeMs": 0,
        "easeInMs": 250,
        "easeOutMs": 250,
        "convertToLightSource": false,
        "lightUseIlluminationShader": false,
        "lightUseBackgroundShader": false,
        "lightFalloffMode": "brightDim",
        "lightColorationIntensity": 1,
        "lightIlluminationIntensity": 1,
        "lightBackgroundIntensity": 1,
        "backgroundGlow": 0,
        "preloadShader": false
      },
      "createdAt": 1772267476826,
      "updatedAt": 1772279967140,
      "thumbnail": "",
      "commonSource": "// Shared controls for the auto-buffer river shader.\n// This source is injected into both the main pass and the nested analysis buffer.\n\nfloat packShoreSettled(float shore, float settled) {\n  return clamp(shore, 0.0, 1.0);\n}\n\nfloat unpackSettled(float packedValue) {\n  return 0.0;\n}\n\nfloat unpackShore(float packedValue) {\n  return clamp(packedValue, 0.0, 1.0);\n}\n\nuniform float uAnalysisBlueBoost; // @editable 0.0 @min 0.0 @max 10.0 @tip \"Boost blue-dominant pixels when blue is already stronger than red and green.\" @order 1\nuniform float uWaterLevel; // @editable 0.5 @min 0.0 @max 1.0 @tip \"Bias the automatically detected shoreline threshold.\" @order 2\nuniform float uAnalysisGamma; // @editable 1.0 @min 0.1 @max 3.0 @tip \"Gamma response applied to the auto-analysis mask and depth.\" @order 3\nuniform float uAnalysisContrast; // @editable 1.0 @min 0.1 @max 3.0 @tip \"Contrast applied to the auto-analysis mask and depth.\" @order 4\n"
    }
  ]
}