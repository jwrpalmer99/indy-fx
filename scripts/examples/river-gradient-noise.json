{
  "version": 1,
  "moduleId": "indy-fx",
  "exportedAt": 1772182800000,
  "shaders": [
    {
      "id": "river-gradient-noise",
      "name": "River Gradient Noise",
      "label": "River Gradient Noise",
      "source": "// River Over Heightmap â€“ Gradient-Noise Variant (top-down)\n// Two-layer parallax FBM with domain-warped eddies.\n// Set iChannel0 to scene capture; luminance is used as a heightmap.\n\nuniform float uFlowAngleDeg;    // @editable 0.0\nuniform float uFlowSpeed;       // @editable 0.30\nuniform float uTurbulence;      // @editable 0.80\nuniform float uWaveScale;       // @editable 3.0\nuniform float uWaterLevel;      // @editable 0.80\nuniform float uTransparency;    // @editable 0.65\nuniform float uRefraction;      // @editable 0.03\nuniform float uDiffraction;     // @editable 0.002\nuniform float uNormalIntensity; // @editable 1.0\nuniform float uSpecularity;     // @editable 0.5\nuniform float uShininess;       // @editable 48.0\nuniform float uFoamIntensity;   // @editable 0.8\nuniform float uFoamWidth;       // @editable 0.06\nuniform float uVortexStrength;  // @editable 0.7\nuniform vec3  uDeepColor;       // @editable 0.03,0.12,0.35\nuniform vec3  uMediumColor;     // @editable 0.08,0.38,0.62\nuniform vec3  uShallowColor;    // @editable 0.22,0.65,0.75\n\nvec2 hash22(vec2 p) {\n  vec2 q = vec2(dot(p, vec2(127.1, 311.7)),\n                dot(p, vec2(269.5, 183.3)));\n  return fract(sin(q) * 43758.5453123);\n}\n\nfloat gnoise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  vec2 g00 = hash22(i)              * 2.0 - 1.0;\n  vec2 g10 = hash22(i + vec2(1, 0)) * 2.0 - 1.0;\n  vec2 g01 = hash22(i + vec2(0, 1)) * 2.0 - 1.0;\n  vec2 g11 = hash22(i + vec2(1, 1)) * 2.0 - 1.0;\n  float na = dot(g00, f);\n  float nb = dot(g10, f - vec2(1, 0));\n  float nc = dot(g01, f - vec2(0, 1));\n  float nd = dot(g11, f - vec2(1, 1));\n  return mix(mix(na, nb, u.x), mix(nc, nd, u.x), u.y) * 0.5 + 0.5;\n}\n\nfloat fbm(vec2 p) {\n  float v = 0.0;\n  float amp = 0.5;\n  mat2 rot = mat2(0.8, -0.6, 0.6, 0.8);\n  for (int i = 0; i < 5; i++) {\n    v += amp * gnoise(p);\n    p = rot * p * 2.02;\n    amp *= 0.5;\n  }\n  return v;\n}\n\nmat2 rot2(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, -s, s, c);\n}\n\nfloat luma(vec3 c) {\n  return dot(c, vec3(0.299, 0.587, 0.114));\n}\n\nfloat sampleHeight(vec2 uv) {\n  return luma(texture(iChannel0, uv).rgb);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  // Heightmap\n  vec4 baseTex = texture(iChannel0, uv);\n  float terrainH = luma(baseTex.rgb);\n\n  // Depth\n  float wl = max(uWaterLevel, 0.01);\n  float depth = clamp(wl - terrainH, 0.0, 1.0);\n  float depthN = depth / wl;\n  float waterMask = smoothstep(0.002, 0.03, depth);\n\n  // Flow\n  float t = iTime * max(0.0, uFlowSpeed);\n  vec2 flowDir = normalize(rot2(radians(uFlowAngleDeg)) * vec2(1.0, 0.0));\n  float turbScale = max(uTurbulence, 0.0);\n  float waveScale = max(uWaveScale, 0.1);\n\n  // Two-layer parallax flow domains\n  vec2 pBase = uv * waveScale;\n  vec2 p1 = pBase + flowDir * t;\n  vec2 p2 = pBase * 0.65 + flowDir * t * 0.55 + vec2(31.7, -17.3);\n\n  // Domain warp for turbulence / eddies\n  vec2 warp1 = vec2(fbm(p1 + vec2(1.7, 2.3)),\n                    fbm(p1 + vec2(-3.1, 0.9))) - 0.5;\n  vec2 warpOff = warp1 * turbScale * 2.5;\n  vec2 wp1 = p1 + warpOff;\n  vec2 wp2 = p2 + warp1 * turbScale * 1.5;\n\n  // Water surface normals (FBM gradient, two layers)\n  float eps = 0.02;\n  float invEps = 1.0 / eps;\n  float h0  = fbm(wp1);\n  float hx  = fbm(wp1 + vec2(eps, 0.0));\n  float hy  = fbm(wp1 + vec2(0.0, eps));\n  float h0b = fbm(wp2);\n  float hxb = fbm(wp2 + vec2(eps, 0.0));\n  float hyb = fbm(wp2 + vec2(0.0, eps));\n  vec2 grad1 = vec2(h0 - hx, h0 - hy) * invEps;\n  vec2 grad2 = vec2(h0b - hxb, h0b - hyb) * invEps;\n  float nStr = max(uNormalIntensity, 0.0);\n  vec2 wNorm = (grad1 * 0.6 + grad2 * 0.4) * nStr;\n  vec3 N = normalize(vec3(-wNorm.x * 0.3, -wNorm.y * 0.3, 1.0));\n\n  // Eddies near shoreline (perpendicular to warp direction)\n  float eddyStrength = exp(-abs(depth) * 10.0) * turbScale;\n  vec2 eddyOff = vec2(-warp1.y, warp1.x) * eddyStrength * 0.05;\n\n  // Terrain slope for foam\n  vec2 texel = 1.0 / iResolution.xy;\n  float hL = sampleHeight(uv - vec2(texel.x, 0.0));\n  float hR = sampleHeight(uv + vec2(texel.x, 0.0));\n  float hD = sampleHeight(uv - vec2(0.0, texel.y));\n  float hU = sampleHeight(uv + vec2(0.0, texel.y));\n  float slope = length(vec2(hR - hL, hU - hD));\n\n  // Refraction with chromatic aberration\n  float rStr = max(uRefraction, 0.0);\n  vec2 refractOffset = N.xy * rStr * (0.25 + depth * 0.75) + eddyOff;\n  vec2 chroma = N.xy * max(uDiffraction, 0.0);\n  vec3 refractedBed = vec3(\n    texture(iChannel0, clamp(uv + refractOffset + chroma, 0.0, 1.0)).r,\n    texture(iChannel0, clamp(uv + refractOffset, 0.0, 1.0)).g,\n    texture(iChannel0, clamp(uv + refractOffset - chroma, 0.0, 1.0)).b\n  );\n\n  // Depth colour ramp\n  float dShallowMid = smoothstep(0.08, 0.45, depthN);\n  float dMidDeep = smoothstep(0.40, 0.95, depthN);\n  vec3 waterColor = mix(uShallowColor, uMediumColor, dShallowMid);\n  waterColor = mix(waterColor, uDeepColor, dMidDeep);\n\n  // Eddies / vortices\n  vec2 flowUV = uv * 9.0 - flowDir * t * 0.75;\n  float eddyNoise = fbm(flowUV + vec2(4.7, -2.1));\n  float eddy = 0.5 + 0.5 * sin((eddyNoise * 2.0 - 1.0) * 9.5 + t * 2.2);\n\n  // Foam: shoreline band + slope detection\n  float foamW = max(uFoamWidth, 0.001);\n  float fAmt = max(uFoamIntensity, 0.0);\n  float foamEdge = smoothstep(wl - foamW, wl + foamW * 0.3, terrainH);\n  float slopeFoam = smoothstep(0.02, 0.12, slope);\n  float foamN = fbm(pBase * 2.0 + warpOff + flowDir * t * 2.0);\n  foamN = smoothstep(0.38, 0.70, foamN);\n  float foam = foamEdge * slopeFoam * foamN;\n\n  // Upstream wisps\n  float foamEdge2 = smoothstep(wl + foamW * 0.3, wl + foamW * 1.5, terrainH);\n  float foamN2 = fbm(pBase * 3.5 + warpOff * 0.7\n                     + flowDir * t * 2.5 + vec2(5.3, -3.7));\n  foamN2 = smoothstep(0.46, 0.76, foamN2);\n  foam += foamEdge2 * foamN2 * 0.5;\n\n  // Shoreline vortices\n  float shoreline = 1.0 - smoothstep(0.03, 0.24, depth);\n  float vortices = shoreline * uVortexStrength * smoothstep(0.6, 0.95, eddy);\n  float foamMask = clamp((foam + vortices * 0.65) * fAmt, 0.0, 1.0);\n\n  // Water body: transparency decreases with depth\n  float transparency = clamp(uTransparency, 0.0, 1.0);\n  float waterOpacity = mix(1.0 - transparency, 1.0, smoothstep(0.0, 1.0, depthN));\n  vec3 waterBody = mix(refractedBed, waterColor, waterOpacity);\n  waterBody += (eddy - 0.5) * 0.08;\n\n  // Specular with Fresnel\n  vec3 L = normalize(vec3(-0.32, -0.26, 0.91));\n  vec3 V = vec3(0.0, 0.0, 1.0);\n  float ndl = clamp(dot(N, L), 0.0, 1.0);\n  float spec = pow(max(dot(reflect(-L, N), V), 0.0), max(4.0, uShininess));\n  float fresnel = pow(1.0 - clamp(dot(N, V), 0.0, 1.0), 3.0);\n  vec3 specCol = vec3(spec * (0.35 + fresnel) * max(uSpecularity, 0.0));\n  waterBody *= 0.86 + 0.14 * ndl;\n\n  // Vortex blend near shore\n  vec2 eddyUV2 = clamp(uv + refractOffset + eddyOff * 2.5, 0.0, 1.0);\n  vec4 eddyTex = texture(iChannel0, eddyUV2);\n  waterBody = mix(waterBody, mix(waterColor, eddyTex.rgb, 0.25),\n                  eddyStrength * 0.2);\n\n  // Composite water\n  vec3 wetResult = waterBody + specCol;\n  wetResult = mix(wetResult, vec3(0.95, 0.98, 1.0), foamMask);\n\n  // Final: water over terrain, keep minimum water visibility for regions\n  vec3 finalColor = mix(baseTex.rgb, wetResult, max(0.35, waterMask));\n  fragColor = vec4(finalColor, 1.0);\n}\n",
      "referencedChannels": [
        0
      ],
      "channels": {
        "iChannel0": {
          "mode": "sceneCapture",
          "path": "",
          "source": "",
          "channels": {},
          "size": 512,
          "volumeTilesX": 0,
          "volumeTilesY": 0,
          "volumeDepth": 0,
          "volumeSizeX": 0,
          "volumeSizeY": 0,
          "volumeSizeZ": 0,
          "samplerFilter": "",
          "samplerWrap": "",
          "samplerVflip": null,
          "samplerInternal": ""
        },
        "iChannel1": {
          "mode": "none",
          "path": "",
          "source": "",
          "channels": {},
          "size": 512,
          "volumeTilesX": 0,
          "volumeTilesY": 0,
          "volumeDepth": 0,
          "volumeSizeX": 0,
          "volumeSizeY": 0,
          "volumeSizeZ": 0,
          "samplerFilter": "",
          "samplerWrap": "",
          "samplerVflip": null,
          "samplerInternal": ""
        },
        "iChannel2": {
          "mode": "none",
          "path": "",
          "source": "",
          "channels": {},
          "size": 512,
          "volumeTilesX": 0,
          "volumeTilesY": 0,
          "volumeDepth": 0,
          "volumeSizeX": 0,
          "volumeSizeY": 0,
          "volumeSizeZ": 0,
          "samplerFilter": "",
          "samplerWrap": "",
          "samplerVflip": null,
          "samplerInternal": ""
        },
        "iChannel3": {
          "mode": "none",
          "path": "",
          "source": "",
          "channels": {},
          "size": 512,
          "volumeTilesX": 0,
          "volumeTilesY": 0,
          "volumeDepth": 0,
          "volumeSizeX": 0,
          "volumeSizeY": 0,
          "volumeSizeZ": 0,
          "samplerFilter": "",
          "samplerWrap": "",
          "samplerVflip": null,
          "samplerInternal": ""
        }
      },
      "defaults": {
        "layer": "inherit",
        "useGradientMask": false,
        "gradientMaskFadeStart": 0.8,
        "alpha": 1,
        "intensity": 1,
        "speed": 1,
        "bloom": false,
        "bloomStrength": 1,
        "bloomBlur": 7,
        "bloomQuality": 2,
        "scale": 1,
        "scaleX": 1,
        "scaleY": 1,
        "scaleToToken": true,
        "tokenScaleMultiplier": 1,
        "scaleWithTokenTexture": true,
        "rotateWithToken": false,
        "flipHorizontal": false,
        "flipVertical": false,
        "shaderRotationDeg": 0,
        "shapeDistanceUnits": 20,
        "falloffPower": 1.6,
        "density": 1,
        "flowMode": 0,
        "flowSpeed": 0.8,
        "flowTurbulence": 0.35,
        "colorA": "031E5B",
        "colorB": "40A8C4",
        "captureScale": 1,
        "captureRotationDeg": 0,
        "captureFlipHorizontal": false,
        "captureFlipVertical": false,
        "displayTimeMs": 0,
        "easeInMs": 250,
        "easeOutMs": 250,
        "convertToLightSource": false,
        "lightUseIlluminationShader": false,
        "lightUseBackgroundShader": false,
        "lightFalloffMode": "brightDim",
        "lightColorationIntensity": 1,
        "lightIlluminationIntensity": 1,
        "lightBackgroundIntensity": 1,
        "backgroundGlow": 0,
        "preloadShader": false
      },
      "createdAt": 1772182800000,
      "updatedAt": 1772182800000,
      "thumbnail": ""
    }
  ]
}
